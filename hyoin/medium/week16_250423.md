
## [medium] 18220-filter


  ### 질문

  원시 타입 또는 유니온 원시 타입인 `Predicate`과 `Predicate`의 요소로 포함되는 배열을 반환하고, 배열 `T`를 가지는 `Filter<T, Predicate>` 타입을 구현하세요.

배열 하나하나 순회하면서 extends로 비교하면될듯?

* 정답
```ts
type Falsy = false | 0 | '' | null | undefined

type Filter<T extends any[], P, Result extends any[] = []> = T extends [infer First, ...infer Rest]
  ? First extends P
    ? Filter<Rest, P, [...Result, First]>
    : Filter<Rest, P, Result>
  : Result

```

------

## [medium] 21104-find-all

  ### Question

  Given a pattern string P and a text string T, implement the type `FindAll<T, P>` that returns an Array that contains all indices (0-indexed) from T where P matches.

T string에서 P string을 모두 찾는데 시작 index들을 배열에 담아 return

```ts
```

------

## [medium] 21106-combination-key-type

  ### Question

  1. Combine multiple modifier keys, but the same modifier key combination cannot appear.
  2. In the `ModifierKeys` provided, the priority of the previous value is higher than the latter value; that is, `cmd ctrl` is OK, but `ctrl cmd` is not allowed.

배열에서 2개씩 뽑아 스페이스를 구분자로 해 이어붙인 조합을 return. 
순서대로 뽑아야하므로 infer로 첫번째 원소를 계속 뽑으며 Rest에 대해 재귀를 돌려줌


* 정답
```ts
type WithSpace<A extends string, B extends string> = `${A} ${B}`

type Combs<T extends any[]> = T extends [infer First extends string, ...infer Rest extends string[]]
  ? WithSpace<First, Rest[number]> | Combs<Rest>
  : never
```

------

## [medium] 21220-permutations-of-tuple

  ### Question

  Given a generic tuple type `T extends unknown[]`, write a type which produces all permutations of `T` as a union.

  For example:

  ```ts
  PermutationsOfTuple<[1, number, unknown]>
  // Should return:
  // | [1, number, unknown]
  // | [1, unknown, number]
  // | [number, 1, unknown]
  // | [unknown, 1, number]
  // | [number, unknown, 1]
  // | [unknown, number ,1]
  ```

```ts
```

------

## [medium] 25170-replace-first


  ### Question

  Implement the type ReplaceFirst<T, S, R> which will replace the first occurrence of S in a tuple T with R. If no such S exists in T, the result should be T.

타입이 나오길래.. Equal 가져다 써야지라고 바로 생각해버림

* 첫 시도(오답)
```ts
type Equal<A, B> = (<T>() => T extends A ? 1 : 2) extends (<T>() => T extends B ? 1 : 2) ? true : false;

type ReplaceFirst<T extends readonly unknown[], 
S, 
R, 
Arr extends unknown[]= []> = T extends [infer First, ...infer Rest]
  ? Equal<First, S> extends true
    ? [...Arr, R, ...Rest]
    : ReplaceFirst<Rest, S, R, [...Arr, First]>
  : Arr

//   Expect<Equal<ReplaceFirst<[1, 'two', 3], string, 2>, [1, 2, 3]>>, 오류
```

Equal이 아닌 extends 로 비교해야하는듯

* 정답
```ts
type ReplaceFirst<T extends readonly unknown[], 
S, 
R, 
Arr extends unknown[]= []> = T extends [infer First, ...infer Rest]
  ? First extends S
    ? [...Arr, R, ...Rest]
    : ReplaceFirst<Rest, S, R, [...Arr, First]>
  : Arr
```

------

## [medium] 25270-transpose

```ts
```

------
