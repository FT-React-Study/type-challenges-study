
## [medium] 9898-appear-only-once

  ### Question

  Find the elements in the target array that appear only once. For example：input: `[1,2,2,3,3,4,5,6,6,6]`，ouput: `[1,4,5]`.

```ts
```

------

## [medium] 9989-count-element-number-to-object

### Question

  With type ``CountElementNumberToObject``, get the number of occurrences of every item from an array and return them in an object. For example:

  ```ts
  type Simple1 = CountElementNumberToObject<[]> // return {}
  type Simple2 = CountElementNumberToObject<[1,2,3,4,5]>
  // return {
  //   1: 1,
  //   2: 1,
  //   3: 1,
  //   4: 1,
  //   5: 1
  // }

  type Simple3 = CountElementNumberToObject<[1,2,3,4,5,[1,2,3]]>
  // return {
  //   1: 2,
  //   2: 2,
  //   3: 2,
  //   4: 1,
  //   5: 1
  // }
  ```

```ts
```

------

## [medium] 10969-integer

  ### Question

  Please complete type `Integer<T>`, type `T` inherits from `number`, if `T` is an integer return it, otherwise return `never`.

* 첫 접근
```ts
type Integer<T extends string|number> = `${T}` extends `${infer _F extends number}.${infer _R}`
  ? never
  : `${T}` extends `${infer TT extends number}`
    ? TT
    : never

// let x = 1
//   Expect<Equal<Integer<typeof x>, never>>,
```

`Integer<number>`를 걸러내지 못했음
명시적으로 넘버리터럴이 아닌 넘버타입이 들어오는 경우를 `number extends T` 로 걸러줬음

* 두 번째 접근(정답)
```ts
type Integer<T extends string|number> = number extends T
  ? never
  : `${T}` extends `${infer _F extends number}.${infer _R}`
    ? never
    : `${T}` extends `${infer TT extends number}`
      ? TT
      : never
```

------

## [medium] 16259-to-primitive

 ### Question

  Convert a property of type literal (label type) to a primitive type.

  For example

  ```typescript
  type X = {
    name: 'Tom',
    age: 30,
    married: false,
    addr: {
      home: '123456',
      phone: '13111111111'
    }
  }

  type Expected = {
    name: string,
    age: number,
    married: boolean,
    addr: {
      home: string,
      phone: string
    }
  }
  type Todo = ToPrimitive<X> // should be same as `Expected`
  ```

```ts
```

------

## [medium] 17973-deep-mutable

  ### Question

  Implement a generic DeepMutable<T> which make every parameter of an object - and its sub-objects recursively - mutable.

  For example

  ```ts
  type X = {
    readonly a: () => 1
    readonly b: string
    readonly c: {
      readonly d: boolean
      readonly e: {
        readonly g: {
          readonly h: {
            readonly i: true
            readonly j: "s"
          }
          readonly k: "hello"
        }
      }
    }
  }

  type Expected = {
    a: () => 1
    b: string
    c: {
      d: boolean
      e: {
        g: {
          h: {
            i: true
            j: "s"
          }
          k: "hello"
        }
      }
    }
  }

  type Todo = DeepMutable<X> // should be same as `Expected`
  ```

```ts
```

------

## [medium] 18142-all

  ### Question

  Returns true if all elements of the list are equal to the second parameter passed in, false if there are any mismatches.

  For example

  ```ts
  type Test1 = [1, 1, 1]
  type Test2 = [1, 1, 2]

  type Todo = All<Test1, 1> // should be same as true
  type Todo2 = All<Test2, 1> // should be same as false
  ```

* 첫 시도(오답)
```ts
type Equal<A, B> = (<T>() => T extends A ? 1 : 2) extends (<T>() => T extends B ? 1 : 2) ? true : false;

type All<T extends any[], U> = Equal<T[number],U> extends true
    ? true
    : false

//  Expect<Equal<All<[1, 1, 2], 1 | 2>, false>>,
```

`T[number]`로 전체 원소를 뽑아내려했으나, 두번째 파라미터로 유니언이 들어오는 TC가 존재해 오답처리됨

=> 원소 하나하나 순회하며 Equal 여부를 판단해야할듯


* 두 번째 시도(정답)
```ts
type Equal<A, B> = (<T>() => T extends A ? 1 : 2) extends (<T>() => T extends B ? 1 : 2) ? true : false;

type All<T extends any[], U> = T extends [infer First, ...infer Rest]
  ? Equal<First,U> extends true
    ? All<Rest,U>
    : false
  : true
```

------