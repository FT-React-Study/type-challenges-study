
## [medium] 459-flatten

배열을 플랫한 배열로 바꾸는 flatten 구현

저번 permutation과 length of string 에서와 같이 임의의 제네릭 변수 R을 추가해서 

T의 원소 하나하나를 계속 넣어주는 재귀 로직을 구현

종결조건은 T가 빈 배열일 경우 재귀 종료

원소가 배열일 경우 스프레드 연산자로 풀어준후 다시 `Flatten` 적용

```
type Flatten<T extends any[], R extends any[] = []> = T extends []
    ? R
    : T extends [infer First, ...infer Rest]
            ? First extends any[]
                ? Flatten<[...First, ...Rest], R>
                : Flatten<Rest,[...R, First]>
            : T
```

--------
## [medium] 527-append-to-object

주어진 인터페이스에 새로운 필드를 추가한 object 타입을 구현하세요. 이 타입은 세 개의 인자를 받습니다.

첫 시도
```
type AppendToObject<T extends object, U extends string|number|symbol, V> = T & Record<U,V>


type test = AppendToObject<test1, 'home', boolean>
// test = test1 & Record<'home',boolean>
```

Record로 오브젝트를 만들어 & 연산을 하려 했으나 계속 오류가 뜸.

Eqaul 연산이 형식 비교이기 때문에 안되는 것 같아 새로운 제네릭 변수 K를 추가해 동일한 연산을 진행한 후 mapped type으로 펼쳐서 새로운 오브젝트를 만듦


두 번째 시도
```
type AppendToObject<T extends object, U extends string|number|symbol, V, K extends object = T & Record<U,V>>= {
    [P in keyof K]: K[P]
} 
```

답지 확인.. keyof T랑 유니언 연산을 하면 되는 구나 깨달아버림

```
type AppendToObject<T, U extends keyof any, V> = {
  [K in keyof T | U]: K extends keyof T ? T[K] : V;
};
```

--------
## [medium] 529-absolute

number, string, 혹은 bigint을 받는 `Absolute` 타입을 만드세요.
출력은 양수 문자열이어야 합니다.

제네릭 변수 T를 템플릿 리터럴을 통해 string으로 변환한 후 첫 글자가 -로 시작하는 지 확인한 후 제거 or 그대로 반환

```
type Absolute<T extends number | string | bigint, ToString extends string = `${T}`> = ToString extends `-${infer Abs}`
    ? Abs
    : ToString
```

--------
## [medium] 459-flatten



```

```

--------
## [medium] 459-flatten



```

```

--------
## [medium] 459-flatten



```

```

--------
