
## [medium] 645-diff

  `O` & `O1`의 차이점인 `객체`를 가져옵니다.

제네릭 파라미터 두 개 전부 객체인 타입이라고 생각한 후 진행.

F와 S에서 서로 겹치지 않는 key들만을 이용해 새로운 객체를 만들어내야하기 때문에 Exclude 유틸리티 타입을 이용했다.

Exclude<A|B,A&B> 라는 연산으로 합집합에서 교집합을 제외한 부분들만 추출해내서 문제를 풀이

```
type Diff<F extends object, S extends object> = {
    [P in Exclude<keyof F | keyof S, keyof F & keyof S>] : P extends keyof F
      ? F[P]
      : P extends keyof S
        ? S[P]
        : never
  }
```

--------

## [medium] 949-any-of

배열 안의 요소를 하나하나 돌면서 빈 배열, 빈스트링, true여부, 빈 오브젝트, nullable 인지 확인하면되지않을까.. 라는 생각으로 접근

조건문 파티를 하자..!

하지만 빈 object 확인하는 라인에서 오류 -> 빈 배열 []

```
type AnyOf<T extends readonly any[]> = T extends [infer First, ...infer Rest]
  ? First extends [infer _, ...infer __] // 빈 배열 확인
    ? true
    : First extends `${infer _}${infer __}` // 빈 스트링 확인
      ? true
      : First extends true // true 확인
        ? true
        : [keyof First] extends [never] // 빈 object 확인
          ? AnyOf<Rest>
          : NonNullable<First> extends First
            ? true
            : AnyOf<Rest>
  : false
```

--------

## [medium] 1042-is-never

  input type으로 `T`를 받는 IsNever type을 구현하세요. 만약 `T`의 유형이 `never`으로 확인되면 `true`를 반환하고 아니면 `false`를 반환합니다


저번 permutation 풀이에서 never여부를 판단하기 위해서는 `T extends never`가 아닌 `T[] extends never[]` 혹은 `[T] extends [never]`와 같은 형식을 이용해야한다는 것이 기억나 바로 적용

```
type IsNever<T> = T[] extends never[]
  ? true
  : false
```

--------

## [medium] 645-diff


```

```

--------

## [medium] 645-diff


```

```

--------
