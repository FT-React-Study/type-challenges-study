## [medium] 4479-chunk

  ### Question

  Do you know `lodash`? `Chunk` is a very useful function in it, now let's implement it.
  `Chunk<T, N>` accepts two required type parameters, the `T` must be a `tuple`, and the `N` must be an `integer >=1`

  ```ts
  type exp1 = Chunk<[1, 2, 3], 2> // expected to be [[1, 2], [3]]
  type exp2 = Chunk<[1, 2, 3], 4> // expected to be [[1, 2, 3]]
  type exp3 = Chunk<[1, 2, 3], 1> // expected to be [[1], [2], [3]]
  ```

튜플과 number를 파라미터로 받은 후 받은 number 만큼씩 튜플의 원소들을 묶어서 return

튜플을 지정 개수대로 나누는 type을 만든 후 이를 이용해 재귀를 돌리면 되겠다..!

* 정답

```ts
type DivideTuple<T extends readonly any[], S extends number, Res extends any[] = []> = [Res['length']] extends [S]
  ? Res
  : T extends [infer TF, ...infer TR]
    ? DivideTuple<TR, S, [...Res, TF]>
    : Res

type Chunk<T extends readonly any[], S extends number> = T extends []
  ? []
  : T extends [...DivideTuple<T, S>, ...infer TR]
    ? [DivideTuple<T, S>, ...Chunk<TR, S>]
    : [DivideTuple<T, S>]
```

-------

## [medium] 4518-fill

  ### Question

  `Fill`, a common JavaScript function, now let us implement it with types.
  `Fill<T, N, Start?, End?>`, as you can see,`Fill` accepts four types of parameters, of which `T` and `N` are required parameters, and `Start` and `End` are optional parameters.
  The requirements for these parameters are: `T` must be a `tuple`, `N` can be any type of value, `Start` and `End` must be integers greater than or equal to 0.

  ```ts
  type exp = Fill<[1, 2, 3], 0> // expected to be [0, 0, 0]
  ```
  In order to simulate the real function, the test may contain some boundary conditions, I hope you can enjoy it :)


```ts
```

-------

## [medium] 4803-trim-right

  ### 질문

  정확한 문자열 타입이고 끝부분의 공백이 제거된 새 문자열을 반환하는 `Trim<T>`를 구현하십시오.

  예시

  ```ts
  type Trimed = TrimRight<'   Hello World    '> // 기대되는 결과는 '   Hello World'입니다.
  ```

예전에 했던 것 같은데 또나옴.. infer와 템플릿 리터럴을 이용해 ' '|'\n'|'\t'를 trim 해줌

* 정답
```ts
type TrimRight<S extends string> = S extends `${infer SF}${' '|'\n'|'\t'}`
  ? TrimRight<SF>
  : S
```

-------

## 

```ts
```

-------

## [medium] 5117-without

  ### Question

  Implement the type version of Lodash.without, Without<T, U> takes an Array T, number or array U and returns an Array without the elements of U.

  ```ts
  type Res = Without<[1, 2], 1>; // expected to be [2]
  type Res1 = Without<[1, 2, 4, 1, 5], [1, 2]>; // expected to be [4, 5]
  type Res2 = Without<[2, 3, 2, 3, 2, 3, 2, 3], [2, 3]>; // expected to be []
  ```

튜플과 넘버|튜플을 파라미터로 받은 후 두번째 파라미터 값에 해당될 경우 제외해 결과값을 return

제외될 튜플을 Union으로 바꾸어 extends 연산 하면 될것이라 생각해 `ToUnion` 타입을 만들어 진행했다.

-> 바로 정답


* 정답
```ts
// 튜플일 경우 union으로, 그외 type엔 그대로 return
type ToUnion<T> = T extends any[] ? T[number] : T

type Without<T extends any[], U, UU = ToUnion<U>> = T extends [infer TF, ...infer TR]
  ? TF extends UU
    ? Without<TR, U>
    : [TF, ...Without<TR, U>]
  : T
```

-------

## [medium] 5140-trunc

  ### Question

  Implement the type version of ```Math.trunc```, which takes string or number and returns the integer part of a number by removing any fractional digits.

  For example:

  ```typescript
  type A = Trunc<12.34> // 12
  ```

number 혹은 number string을 받아 소수점 밑을 전부 버리는 `trunc`를 구현.

템플릿 리터럴의 패턴매칭을 이용해 `.` 앞 뒤로 짜른 후 앞 부분을 이용하면 될 것이라 생각한 후 진행했다.

`'.123'`과 같이 소수점 앞의 부분이 없는 string이 들어올 경우 0을 리턴해야 하므로 이에 대한 예외처리를 진행

=> 정답

* 정답
```ts
type Trunc<T extends number|string> = `${T}` extends `${infer TS}.${infer TE}`
  ? TS extends ''
    ? '0'
    : TS
  : `${T}`
```

-------

